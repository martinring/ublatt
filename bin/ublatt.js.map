{
  "version": 3,
  "sources": ["../src/cli/ublatt.ts", "../src/cli/build.ts", "../src/cli/metadata.ts", "../src/cli/modules.ts", "../src/cli/markdown.ts", "../src/cli/externals.ts", "../src/shared/templates/main.ts", "../src/shared/templates/header.ts", "../src/shared/templates/submit.ts", "../src/cli/render.ts", "../src/cli/summary.ts", "../src/cli/evaluate.ts"],
  "sourcesContent": ["#!/usr/bin/env node\nimport 'source-map-support/register.js'\n\nimport * as process from 'process';\nimport yargs, { string } from 'yargs';\nimport build from './build';\nimport summary from './summary';\nimport { dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport evaluate from './evaluate';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(dirname(__filename));\n\nyargs(process.argv.slice(2))\n  .scriptName('ublatt')  \n  .options({\n    meta: {\n      type: \"array\",\n      description: \"path to meta yaml file\",\n      default: [] as string[],\n      global: true,\n    }\n  })\n  .command(\n    'build [source]',\n    'generate interactive exercise sheets',\n    (argv) => {\n      return argv.options({\n        out: {\n          alias: 'o',\n          type: \"string\",\n          description: \"file to write to\",\n          default: 'stdout'\n        },\n        standalone: {     \n          type: 'boolean',\n          default: false\n        },\n        dataDir: {\n          type: \"string\",\n          default: __dirname,\n          hidden: true\n        }        \n      }).positional('source',{\n        type: 'string',\n        default: 'stdin'\n      }).check((args) => {\n        if (args.source == 'stdin' && process.stdin.isTTY) {\n          throw new Error('nothing to read from stdin')\n        } else return true\n      })\n    },    \n    build\n  )\n  .command(\n    'summary [dir]',\n    'analyse a directory of handins',\n    (argv) => argv.options({\n      dir: {\n        'type': 'string',\n        'default': '.'\n      }\n    }),\n    summary\n  )\n  .command(\n    'evaluate file',\n    'evaluate a solution',\n    (argv) => argv.options({\n      out: {\n        alias: 'o',\n        type: \"string\",\n        description: \"file to write to\",\n        default: 'stdout'\n      },\n      file: {\n        'type': 'string',\n        'required': true  \n      },\n      dataDir: {\n        type: \"string\",\n        default: __dirname,\n        hidden: true\n      }\n    }),\n    evaluate\n  )\n  .demandCommand()\n  .help()\n  .argv", "import * as fs from 'fs';\nimport * as path from 'path';\nimport { mergeMetadata, parseMetadata, extractMetadata } from './metadata';\nimport extractModules, { Modules } from './modules';\nimport Markdown from './markdown'\nimport esbuild from 'esbuild';\nimport { Solution, Student } from '../shared/Types';\nimport { readFile } from 'fs/promises';\nimport externals from './externals';\nimport Main from '../shared/templates/main';\nimport Header from '../shared/templates/header';\nimport Submit from '../shared/templates/submit';\nimport render from './render';\nimport { buildParserFile } from 'lezer-generator';\n\n//import * as pack from '../../package.json';\n\nexport type BuildOptions = {\n  source: string,\n  out: string,\n  meta?: string[],\n  submission?: Solution,\n  solution?: Solution,\n  standalone: boolean,\n  dataDir: string\n}\n\nexport default async function build(options: BuildOptions) {\n    const dir = options.source == 'stdin' ? '.' : path.parse(options.source).dir\n    const f = fs.readFileSync(options.source == 'stdin' ? 0 : options.source).toString('utf-8');\n\n    const modules = extractModules(options.dataDir + '/src/runtime/modules');        \n\n    const meta: { [key: string]: any } = {\n      lang: Intl.DateTimeFormat().resolvedOptions().locale.split('-')[0],\n      eval: (options.submission || options.solution) ? true : undefined\n    };           \n\n    if (options.meta) {\n      options.meta.forEach(x => {\n        const src = fs.readFileSync(x).toString('utf-8')\n        const m = parseMetadata(src)        \n        mergeMetadata(m,meta)        \n      })\n    }\n    \n    const markdown = extractMetadata(f,meta);\n\n    meta.author = meta.author || []\n\n    var pagetitle = \"\" \n    if (meta['sheet'] !== undefined) pagetitle += meta['sheet'].toString() + (meta.i18n?.[\"sheet-title\"] || \". \u00DCbungsblatt\") + \" - \"\n    pagetitle += meta['title'] || \"ublatt\"\n    if (meta['subtitle']) pagetitle += \" - \" + meta['subtitle']\n\n    if (options.submission) {\n      meta['authors'] = options.submission.authors\n    }\n\n    const imports = [\n      \"import Ublatt from './src/runtime/ublatt'\"\n    ]\n\n    const imported = new Set<string>()\n\n    const inits = [\n      `const meta = ${JSON.stringify(meta)}`,\n      `const ublatt = new Ublatt(document.querySelector('form.ublatt'),meta)`,\n      `window.ublatt = ublatt`\n    ]  \n    \n    function findModules(base: string, modules: Modules, classes: string[], parent: string) {\n      if (modules.size > 0) {\n        classes.forEach(c => {          \n          const submodules = modules.get(c)          \n          if (submodules) {   \n            const path = `${base}/${c}`         \n            if (!imported.has(path)) {\n              imported.add(path)\n              imports.push(`import ${c.charAt(0).toUpperCase() + c.slice(1)} from '${path}'`)\n              inits.push(`const ${c} = new ${c.charAt(0).toUpperCase() + c.slice(1)}()`)\n              inits.push(`${parent}.registerModule('${c}',${c})`)\n            }\n            findModules(base + \"/\" + c, submodules, classes, c)\n          }\n        })\n      }\n    }\n\n    const md = new Markdown({\n      dir: dir,\n      processClasses(x) {\n        return findModules(\"./src/runtime/modules\",modules,x,\"ublatt\")\n      },\n      standalone: options.standalone\n    })\n\n    const body: string = md.render(markdown);\n    \n    const initArgs = []\n    \n    if (options.submission) {\n      const sub = options.submission\n      meta['author'] = sub.authors.map((a: Student) => a.name)    \n      initArgs.push(JSON.stringify(sub))\n    }    \n  \n    if (options.solution) {\n      let solution = options.solution      \n      initArgs.push(JSON.stringify(solution))\n    }\n\n    inits.push(`ublatt.init(${initArgs.join(\", \")})`) \n\n    let script: string = imports.join(\"; \") + \";\" + inits.join(\"; \")  \n    let style: string = ''     \n\n    const bundle = await esbuild.build({\n      stdin: {\n        contents: script,\n        resolveDir: options.dataDir\n      },\n      bundle: true,\n      platform: \"browser\",\n      format: 'esm',\n      outdir: options.dataDir + '/dist',\n      write: false,\n      loader: {\n        '.woff': 'dataurl',\n        '.svg': 'dataurl'        \n      },\n      plugins: [\n        {\n          name: 'externals',\n          setup(build) {\n            build.onResolve({ filter: externals.filter }, (args) => {              \n              return {\n                external: true,\n                path: externals.path(args.path) \n              }\n            })\n          }\n        },\n        {\n          name: \"lezer\",\n          setup(build) {\n            build.onLoad({ filter: /\\.grammar$/ }, async (args) => { \n              const source = await readFile(args.path, { encoding: 'utf-8' });\n              const { parser } = buildParserFile(source, {\n              })\n              return {\n                contents: parser,\n                loader: 'js'\n              }\n            })\n          }\n        }],\n      minify: true\n    })\n\n    bundle.warnings?.forEach(console.warn)        \n\n    if (bundle.outputFiles) {\n      script = bundle.outputFiles[0].text.replaceAll(\"</script>\",\"<\\\\/script>\")\n      style = bundle.outputFiles[1].text\n    }\n\n    /*meta['$css'] = meta['$css'].map((x: string) => {\n      let alt = x.replace('./src/runtime','./dist')      \n      if (fs.existsSync(options.dataDir + '/' + alt)) x = alt      \n      if (options.standalone) {\n        const p = options.dataDir + '/' + x\n        let css = fs.readFileSync(p).toString('utf-8')\n        css = css.replaceAll(/url\\(['\"]?([a-zA-Z\\.\\/0-9_@-]+)['\"]?\\)/g,(x,y) => {\n          const data = fs.readFileSync(path.parse(p).dir + '/' + y).toString('base64')\n          let mime\n          switch (path.parse(y).ext) {\n            case ('.woff'): mime = 'font/woff'; break;\n            case ('.png'): mime = 'image/png'; break;\n            case ('.jpg'): mime = 'image/jpg'; break;\n            case ('.svg'): mime = 'image/svg+xml'; break;\n            default: mime = 'text/plain'; break;\n          }\n          return `url(data:${mime};base64,${data})`\n        })\n        return `<style>\\n${css}\\n</style>`\n      } else return `<link rel=\"stylesheet\" href=\"${x}\"/>`\n    })*/\n\n    meta['$dir'] = \"dist\";\n\n    //const footerTemplateSrc = fs.readFileSync(options.dataDir + \"/templates/submit.html\").toString('utf-8')\n    //const footerTemplate = handlebars.compile(footerTemplateSrc)\n    \n    //if (!options.submission) meta['$footer'] = footerTemplate(meta)\n\n\n    //const templateSrc = fs.readFileSync(options.dataDir + '/templates/ublatt.html').toString('utf-8');\n    //const template = handlebars.compile(templateSrc)\n\n    const footer: string = render(\u00B5 => \u00B5.when(!options.submission, () => Submit({ buttons: 'submit-buttons' })(\u00B5)))\n\n    meta.authors = meta.authors || meta.author.map((x: string) => ({name: x}))\n\n    const output = render(Main({\n      lang: meta.lang,\n      authors: meta.authors || [],\n      pagetitle, \n      header: render(Header(meta)),\n      body,\n      script,\n      style,\n      footer\n    }))\n\n    if (options.out == 'stdout') {\n        process.stdout.write(output)\n    } else {        \n        fs.writeFileSync(options.out, output)\n    }\n}", "import yaml from 'yaml';\nimport * as fs from 'fs/promises';\nimport { Author } from '../shared/Types';\n\nexport type Metadata = {\n  sheet?: string;\n  title?: string;\n  lang?: string;\n  author?: Author[];\n  [id: string]: any;\n}\n\nexport function loadMetadata(path: string | string[]): Promise<Metadata> {\n  if (typeof path == \"string\") {\n    return fs.readFile(path).then(x => x.toString('utf-8')).then(yaml.parseDocument)\n  } else {\n    return path.map(loadMetadata).reduce(async (a,b) => {\n      const a_ = await a\n      const b_ = await b\n      return mergeMetadata(a_,b_)\n    })\n  }\n}\n\nexport function parseMetadata(input: string): Metadata {\n  return yaml.parse(input)\n}\n\n/** merges all properties set in `from` to `to` */\nexport function mergeMetadata(from: Metadata, to: Metadata): Metadata {\n  Object.keys(from).forEach(key => {\n    to[key] = from[key]\n  })\n  return to\n}\n\n/** extracts metadata blocks from input */\nexport function extractMetadata(input: string, meta: Metadata): string {  \n  const lines = input.split('\\n')\n  var start = null\n  var blank = true\n  var i = 0\n  var buf = \"\"\n  while (i < lines.length) {    \n    if (typeof start == \"number\") {\n      if (lines[i].match(/^(---|...)\\s*$/)) {\n        try {\n          const x = parseMetadata(buf)\n          Object.keys(x).forEach(key => {\n            meta[key] = x[key]\n          })\n          lines.splice(start, i - start + 1)\n        } catch (e) {\n          console.warn(e)\n          i = i - (i - start + 1)\n        }\n        start = null\n        blank = false\n        buf = \"\"\n      } else {\n        buf += lines[i] + \"\\n\"\n      }\n    } else {\n      if (blank && lines[i].match(/^---\\s*$/)) {\n        start = i\n      } else if (lines[i].match(/^\\s*$/)) {\n        blank = true\n      } else {\n        blank = false\n      }\n    }\n    i += 1;\n  }\n  return lines.join('\\n');\n}\n", "import { existsSync, lstatSync, readdirSync, PathLike }  from 'fs';\nimport { parse } from 'path';\n\nexport type Modules = Map<string,Modules>\n\nexport default function extractModules(base: PathLike): Modules {    \n    let result = new Map()  \n    if (existsSync(base) && lstatSync(base).isDirectory) {\n        readdirSync(base).forEach((file) => {\n            const p = parse(file)\n            if (p.ext == '.ts' || p.ext == '.tsx') {\n                let submodules = extractModules(`${base}/${p.name}`)\n                result.set(p.name,submodules)                    \n            }\n        })\n    }\n    return result\n}", "import markdownit from 'markdown-it';\nimport container from 'markdown-it-container';\nimport texmath from 'markdown-it-texmath';\nimport katex from 'katex';\nimport bspans from 'markdown-it-bracketed-spans';\nimport attrs from 'markdown-it-attrs';\nimport secs from 'markdown-it-header-sections';\nimport Token from 'markdown-it/lib/token';\nimport MarkdownIt from 'markdown-it';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface MarkdownOptions {\n    dir: string,\n    processClasses?: (classes: string[]) => void,\n    standalone?: boolean\n}\n\nexport default class Markdown {    \n    readonly md: MarkdownIt\n\n    constructor(options: MarkdownOptions) {\n        this.md = markdownit().use(container, 'classes', {\n            validate(params: string) {\n                return params.trim().match(/^(\\w+\\s+)*\\w+$/)\n            },\n            render(tokens: Token[], idx: number) {\n                const classes = tokens[idx].info.trim().split(/\\s+/)\n                options.processClasses?.(classes)\n                if (tokens[idx].nesting === 1) {\n                    // opening tag\n                    return `<div class=\"${classes.join(' ')}\">\\n`;\n                } else {\n                    // closing tag\n                    return '</div>\\n';\n                }\n            }\n        })\n            .use(texmath, { engine: katex, delimiters: 'dollars' })\n            .use(bspans)\n            .use(attrs)\n            .use(secs)\n\n        if (options.processClasses) {\n            const processClasses = options.processClasses\n            const renderAttrs = this.md.renderer.renderAttrs\n            this.md.renderer.renderAttrs = function (tkn) {\n                if (tkn.attrs) {\n                    const c = tkn.attrs.find(x => x && x[0] == \"class\")\n                    if (c) {\n                        const classes = c[1].split(/\\s+/);\n                        processClasses(classes);\n                    }\n                }\n                return renderAttrs(tkn)\n            }\n        } \n\n        this.md.renderer.rules.image = function (tokens, idx, opts, env, slf) {\n            const token = tokens[idx];\n            let src = token.attrGet('src')            \n            if (src && fs.existsSync(options.dir + '/' + src)) {\n                const mime = 'image/' + path.parse(src).ext.slice(1)\n                const uri = `data:${mime};base64,${fs.readFileSync(options.dir + '/' + src).toString('base64')}`\n                token.attrSet('src', uri)\n            } else {\n                console.warn(src + \" does not exist\")\n            }\n            return slf.renderToken(tokens,idx,opts)\n        }\n\n        this.md.renderer.rules.fence = function (tokens, idx, options, env, slf) {\n            const token = tokens[idx];\n            token.attrJoin('class',token.info)            \n            return '<pre' + slf.renderAttrs(token) + '>'\n                + '<code>' + token.content + '</code>'\n                + '</pre>';            \n        }\n    }\n\n    public render(input: string): string {\n        return this.md.render(input)\n    }\n}", "// @ts-ignore\nimport externals from '../../externals.json';\n// @ts-ignore\nimport pack from '../../package.json';\n\ntype Dict = { [key: string]: string }\n\nexport default {\n    filter: RegExp(`^(${Object.keys(externals).join('|')})$`),\n    path(key: string): string | undefined {        \n        return (externals as Dict)[key].replace(/\\$\\{\\s*version\\s*\\}/,(pack.dependencies as Dict)[key])\n    } \n}", "import type { Author } from '../Types'\nimport type { Renderer, Fragment } from './template'\n\nexport default function <T extends Renderer> (props: {\n  lang: string\n  authors: Author[]\n  pagetitle: string\n  script: string\n  style: string\n  header?: Fragment<T>\n  body: Fragment<T>\n  footer?: Fragment<T>\n}) {\n  return (h: T) =>\n    h.fragment(\n      h.fromString('<!DOCTYPE html>'),\n      h('html',{ lang: props.lang },  \n        h('head',{},\n          h('meta',\u00A0{ name: 'generator', content: 'ublatt' }),          \n          h('meta', { attributes: { charset: 'utf8' }}),\n          h.fragment(...props.authors.map(a => h('meta',{ name: 'author', content: a.name }))),\n          h('title',{},props.pagetitle),\n          h('script',{ type: 'module' },props.script),\n          h('style',{},props.style)\n        ),\n        h('body',{},\n          h('form',{ class: 'ublatt' },\n            props.header,\n            h('div',{ class: 'main' }, props.body),\n            props.footer\n          )\n        )\n      )  \n    )\n}", "import { Author } from '../Types'\nimport type { Renderer, HTML } from './template'\n\nexport default function<T extends Renderer>(props: {\n  title?: string  \n  subtitle?: string\n  authors?: Author[]\n  sheet?: string\n  date?: string\n  due?: string\n}) {\n  return (h: T) => \n    h('div',{ class: 'head' },\n      h.when(props.title, () => h('span',{ class: 'title' },props.title)),\n      h.when(props.subtitle, () => h('span',{ class: 'term' },props.subtitle)),\n      h('ul',{ class: 'lecturers' },\n        ...(props.authors || []).map(a => h('li',{},a.name))\n      ),\n      h.when(props.sheet, () => h('span',{ class: 'sheetnum' },`${props.sheet}. \u00DCbungsblatt`)),    \n      h.when(props.date, () => h.fragment(\n        h('span',{ class: 'issued-title' }, 'Ausgabe: '),\n        h('span',{ class: 'issued' }, props.date)\n      )),\n      h.when(props.due, () => h.fragment(\n        h('span',{ class: 'due-title' }, 'Abgabe: '),\n        h('span',{ class: 'due' }, props.due)\n      ))  \n    )\n}", "import { Renderer } from \"./template\";\n\nexport default function <T extends Renderer> (props: {\n  buttons: string\n}) {\n  return (\u00B5: T) => (\n    \u00B5('div', { class: 'submit' },\n      \u00B5('div', {},\n        \u00B5('h1', {}, 'Autoren'),\n        \u00B5('div', { class: 'authors' })\n      ),\n      \u00B5('div', {},\n        \u00B5('h1', {}, 'Abgabe'),\n        \u00B5('p',{},'Bitte gebt alle Autoren mit Matrikelnummer und Emailaddresse ' +\n          'an und speichert dann eure L\u00F6sung. Die gespeicherte JSON Datei sendet ' +\n          'ihr dann an beide Tutoren per E-Mail.'),\n        \u00B5('div',{ class: 'buttons', id: props.buttons },\n        )        \n      )\n    )\n  )\n}", "\nimport { StaticRenderer, HTML, Props } from \"../shared/templates/template\";\n\nconst voidTags = new Set<HTML>([\n  'area','base','br','col','embed','hr','img','input',\n  'link','meta','param','source','track','wbr'])\n\nexport const renderer: StaticRenderer = Object.assign(\n  function <K extends HTML>(k: K, props: Props<K>, ...children: string[]): string {\n    const attrs = Object.entries(props).map(([k,v]) => {\n      switch (k) {\n        case 'attributes':\n          return Object.entries(v).map(([k,v]) => `${k}=\"${v}\"`).join(' ')\n        case 'data':\n          return Object.entries(v).map(([k,v]) => `data-${k}=\"${v}\"`).join(' ')\n        case 'class':\n          return `class=\"${Array.isArray(v) ? v.join(' ') : v}\"`\n        default:\n          return `${k.toLowerCase()}=\"${v}\"`        \n      }\n    }).join(' ')\n    if (children.length == 0 && voidTags.has(k)) {    \n      return `<${k} ${attrs}/>`\n    } else {\n      return `<${k} ${attrs}>\\n${children.join('')}\\n</${k}>`\n    }\n  },\n  {\n    fragment(...items: string[]) {\n      return items.join('')\n    },    \n    fromString(v: string) {\n      return v\n    },\n    empty() { return '' },\n    when(p: any, t: () => string) {\n      return p ? t() : ''\n    } \n  }\n)\n\nexport default function render(template: (r: StaticRenderer) => string) {\n  return template(renderer)\n}", "import { Solution, Student } from '../shared/Types'\nimport * as fs from 'fs';\nimport * as path from 'path'\n\ntype SummaryOptions = {\n  dir: string\n}\n\nexport default function summary(options: SummaryOptions) {\n    let course: string | null = null\n    const sheets: { [id: string]: Solution[] } = {}\n    const students: { [id: string]: Student } = {}\n    const handins: { [id: string]: { [id: string]: Solution }} = {}\n    fs.readdirSync(options.dir).filter(x => path.parse(x).ext == '.json').map(x => {        \n      const src = fs.readFileSync(options.dir + x).toString('utf-8')\n      const obj = JSON.parse(src) as Solution\n      if (course == null) {\n        course = obj.course\n      } else if (course != obj.course) {\n        console.error(`- found submissions to multiple courses (${course} and ${obj.course})`)\n      }\n      obj.authors.forEach(a => {        \n        students[a.matriculation_number] = students[a.matriculation_number] || a\n        if (!handins[a.matriculation_number]) handins[a.matriculation_number] = {}\n        if (handins[a.matriculation_number][obj.sheet])\n          console.warn(`- multiple submissions for sheet ${obj.sheet} from ${a.name} (${a.matriculation_number})`)\n        else\n          handins[a.matriculation_number][obj.sheet] = obj\n      })\n      if (!sheets[obj.sheet]) sheets[obj.sheet] = []\n      sheets[obj.sheet].push(obj)\n    })\n    console.log(\"## Sheets\\n\")\n    Object.entries(sheets).forEach(([x,y]) => {\n      console.log(`- sheet ${x}: ${y.length} handins from ${y.map(x => x.authors.length).reduce((x,y) => x + y)} students`)\n    })    \n    console.log(\"\\n## Missing handins\\n\")\n    Object.entries(students).forEach(([x,y]) => {\n      const e = handins[y.matriculation_number]\n      const missing = Object.keys(sheets).filter(x => e[x] === undefined)    \n      if (missing.length > 0) \n        console.log(`- ${y.name} (${x}): ${missing.join(\", \")}`)\n    })\n    console.log(\"\\n\")\n    \n}", "import { Solution, Student } from '../shared/Types'\nimport * as fs from 'fs';\nimport build, { BuildOptions }  from './build';\nimport { extractMetadata, Metadata, parseMetadata } from './metadata';\n\ntype EvaluateOptions = BuildOptions & {  \n  file: fs.PathLike\n}\n\nexport default function evaluate(options: EvaluateOptions) {  \n  function makeBuildOptions(s: Solution): BuildOptions {\n    const opts = Object.assign({},options)\n    const y = fs.readdirSync('./solutions') // TODO: make search path configurable\n      .filter(x => x.endsWith('.json'))\n      .map(x => JSON.parse(fs.readFileSync('./solutions/' + x).toString('utf-8')) as Solution)\n      .find(x => x.sheet == s.sheet)\n    const z = fs.readdirSync('./sheets') // TODO: make search path configurable\n      .filter(x => x.endsWith('.md'))\n      .map(x => './sheets/' + x).find(x => {\n        const meta: Metadata = {}\n        extractMetadata(fs.readFileSync(x).toString('utf-8'), meta)\n        return meta.sheet == s.sheet\n      })\n    opts.submission = s\n    opts.solution = y\n    if (!z) throw new Error(\"could not find sheet\")\n    opts.source = z\n    return opts\n  }\n  if (fs.statSync(options.file).isDirectory()) {\n    const counters: { [i: string]: number } = { }\n    const xs = fs.readdirSync(options.file).filter(x => x.endsWith('.json')).forEach(x => {          \n      const c = fs.readFileSync(options.file + '/' + x).toString('utf-8')\n      const s = JSON.parse(c) as Solution\n      const opts = makeBuildOptions(s)\n      const n = counters[s.sheet] = counters[s.sheet] + 1 || 1      \n      opts.out = `${options.file}/sheet${s.sheet}-${n}.html`\n      build(opts)\n    })\n  } else {\n    const x = fs.readFileSync(options.file).toString('utf-8')\n    const s = JSON.parse(x) as Solution\n    build(makeBuildOptions(s))\n  }\n}"],
  "mappings": "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",
  "names": []
}

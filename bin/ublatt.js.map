{
  "version": 3,
  "sources": ["../src/shared/languages/ocl.ts", "../src/cli/ublatt.ts", "../src/cli/build.ts", "../src/cli/metadata.ts", "../src/cli/modules.ts", "../src/cli/markdown.ts", "../src/shared/codemirror/highlight.ts", "../src/shared/languages/ocl.grammar", "../src/shared/codemirror/languages.ts", "../src/cli/externals.ts", "../src/shared/templates/main.ts", "../src/shared/templates/header.ts", "../src/shared/templates/submit.ts", "../src/cli/render.ts", "../src/cli/summary.ts", "../src/cli/evaluate.ts"],
  "sourcesContent": ["import { parser } from './ocl.grammar';\nimport { LezerLanguage } from '@codemirror/language';\nimport { styleTags, tags as t } from \"@codemirror/highlight\";\n\nexport default LezerLanguage.define({\n  parser: parser.configure({\n    props: [ styleTags({\n      self: t.self,\n      \"if then else endif\": t.controlKeyword,\n      \"package endpackage\": t.keyword,\n      \"true false null invalid let in context inv pre post init derive\": t.keyword,\n      \"and or implies xor\": t.keyword,\n      \"Set Bag Sequence Collection OrderedSet Tuple\": t.typeName,      \n      \"OclAny OclInvalid OclMessage OclVoid\": t.typeName,\n      \"Boolean Integer Real String UnlimitedNatural\": t.typeName,\n      PreMarker: t.special(t.keyword),\n      Type: t.typeName,\n      SimpleName: t.keyword,\n      BlockComment: t.blockComment,\n      StringLiteral: t.string,\n      NumericLiteral: t.number,\n      LineComment: t.lineComment,\n      EnumLiteral: t.literal,            \n      MethodName: t.function(t.variableName),\n      PropertyName: t.propertyName,\n      Namespace: t.namespace,\n      VariableName: t.definition(t.variableName),\n      \"( )\": t.paren,\n      \"^ ^^\": t.operatorKeyword\n    }) ]\n  }),\n  languageData: {    \n  }\n})", "#!/usr/bin/env node\nimport 'source-map-support/register.js'\n\nimport * as process from 'process';\nimport yargs, { string } from 'yargs';\nimport build from './build';\nimport summary from './summary';\nimport { dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport evaluate from './evaluate';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(dirname(__filename));\n\nyargs(process.argv.slice(2))\n  .scriptName('ublatt')  \n  .options({\n    meta: {\n      type: \"array\",\n      description: \"path to meta yaml file\",\n      default: [] as string[],\n      global: true,\n    },\n    debug: {\n      type: \"boolean\",\n      description: \"include original sources for debugging\",\n      default: false,\n      global: true\n    }\n  })\n  .command(\n    'build [source]',\n    'generate interactive exercise sheets',\n    (argv) => {\n      return argv.options({\n        out: {\n          alias: 'o',\n          type: \"string\",\n          description: \"file to write to\",\n          default: 'stdout'\n        },\n        standalone: {     \n          type: 'boolean',\n          default: false\n        },\n        dataDir: {\n          type: \"string\",\n          default: __dirname,\n          hidden: true\n        }        \n      }).positional('source',{\n        type: 'string',\n        default: 'stdin'\n      }).check((args) => {\n        if (args.source == 'stdin' && process.stdin.isTTY) {\n          throw new Error('nothing to read from stdin')\n        } else return true\n      })\n    },    \n    build\n  )\n  .command(\n    'summary [dir]',\n    'analyse a directory of handins',\n    (argv) => argv.options({\n      dir: {\n        'type': 'string',\n        'default': '.'\n      }\n    }),\n    summary\n  )\n  .command(\n    'evaluate file',\n    'evaluate a solution',\n    (argv) => argv.options({\n      out: {\n        alias: 'o',\n        type: \"string\",\n        description: \"file to write to\",\n        default: 'stdout'\n      },\n      file: {\n        'type': 'string',\n        'required': true  \n      },\n      dataDir: {\n        type: \"string\",\n        default: __dirname,\n        hidden: true\n      }\n    }),\n    evaluate\n  )\n  .demandCommand()\n  .help()\n  .argv", "import * as fs from 'fs';\nimport * as path from 'path';\nimport { mergeMetadata, parseMetadata, extractMetadata } from './metadata';\nimport extractModules, { Modules } from './modules';\nimport Markdown from './markdown'\nimport esbuild from 'esbuild';\nimport { Solution, Student } from '../shared/Types';\nimport { readFile } from 'fs/promises';\nimport externals from './externals';\nimport Main from '../shared/templates/main';\nimport Header from '../shared/templates/header';\nimport Submit from '../shared/templates/submit';\nimport render from './render';\nimport { buildParserFile } from 'lezer-generator';\n\n//import * as pack from '../../package.json';\n\nexport type BuildOptions = {\n  source: string,\n  out: string,\n  meta?: string[],\n  submission?: Solution,\n  solution?: Solution,\n  standalone: boolean,\n  dataDir: string,\n  debug: boolean\n}\n\nexport default async function build(options: BuildOptions) {\n    const dir = options.source == 'stdin' ? '.' : path.parse(options.source).dir\n    const f = fs.readFileSync(options.source == 'stdin' ? 0 : options.source).toString('utf-8');\n\n    const modules = extractModules(options.dataDir + '/src/runtime/modules');        \n\n    const meta: { [key: string]: any } = {\n      lang: Intl.DateTimeFormat().resolvedOptions().locale.split('-')[0],\n      eval: (options.submission || options.solution) ? true : undefined\n    };           \n\n    if (options.meta) {\n      options.meta.forEach(x => {\n        const src = fs.readFileSync(x).toString('utf-8')\n        const m = parseMetadata(src)        \n        mergeMetadata(m,meta)        \n      })\n    }\n    \n    const markdown = extractMetadata(f,meta);\n\n    meta.author = meta.author || []\n\n    var pagetitle = \"\" \n    if (meta['sheet'] !== undefined) pagetitle += meta['sheet'].toString() + (meta.i18n?.[\"sheet-title\"] || \". \u00DCbungsblatt\") + \" - \"\n    pagetitle += meta['title'] || \"ublatt\"\n    if (meta['subtitle']) pagetitle += \" - \" + meta['subtitle']\n\n    if (options.submission) {\n      meta['authors'] = options.submission.authors\n    }\n\n    const imports = [\n      \"import Ublatt from './src/runtime/ublatt'\"\n    ]\n\n    const imported = new Set<string>()\n\n    const inits = [\n      `const meta = ${JSON.stringify(meta)}`,\n      `const ublatt = new Ublatt(document.querySelector('form.ublatt'),meta)`,\n      `window.ublatt = ublatt`\n    ]  \n    \n    function findModules(base: string, modules: Modules, classes: string[], parent: string) {\n      if (modules.size > 0) {\n        classes.forEach(c => {          \n          const submodules = modules.get(c)          \n          if (submodules) {   \n            const path = `${base}/${c}`         \n            if (!imported.has(path)) {\n              imported.add(path)\n              imports.push(`import ${c.charAt(0).toUpperCase() + c.slice(1)} from '${path}'`)\n              inits.push(`const ${c} = new ${c.charAt(0).toUpperCase() + c.slice(1)}()`)\n              inits.push(`${parent}.registerModule('${c}',${c})`)\n            }\n            findModules(base + \"/\" + c, submodules, classes, c)\n          }\n        })\n      }\n    }\n\n    const md = new Markdown({\n      dir: dir,\n      processClasses(x) {\n        return findModules(\"./src/runtime/modules\",modules,x,\"ublatt\")\n      },\n      standalone: options.standalone\n    })\n\n    const body: string = await md.render(markdown);\n    \n    const initArgs = []\n    \n    if (options.submission) {\n      const sub = options.submission\n      meta['author'] = sub.authors.map((a: Student) => a.name)    \n      initArgs.push(JSON.stringify(sub))\n    }    \n  \n    if (options.solution) {\n      let solution = options.solution      \n      initArgs.push(JSON.stringify(solution))\n    }\n\n    inits.push(`ublatt.init(${initArgs.join(\", \")})`) \n\n    let script: string = imports.join(\";\\n\") + \";\" + inits.join(\";\\n\")  \n    let style: string = ''     \n\n    const bundle = await esbuild.build({\n      stdin: {\n        contents: script,\n        resolveDir: options.dataDir,\n        sourcefile: 'init.ts'\n      },\n      bundle: true,\n      platform: \"browser\",\n      format: 'esm',\n      outdir: options.dataDir + '/dist',\n      write: false,\n      target: 'es2018',\n      charset: 'utf8',\n      color: true,\n      sourcemap: options.debug? 'inline' : false,\n      sourcesContent: options.debug,\n      loader: {\n        '.woff': 'dataurl',\n        '.svg': 'dataurl'        \n      },\n      plugins: [\n        {\n          name: 'externals',\n          setup(build) {\n            build.onResolve({ filter: externals.filter }, (args) => {              \n              return {\n                external: true,\n                path: externals.path(args.path) \n              }\n            })\n          }\n        },\n        {\n          name: \"lezer\",\n          setup(build) {\n            build.onLoad({ filter: /\\.grammar$/ }, async (args) => { \n              const source = await readFile(args.path, { encoding: 'utf-8' });\n              const { parser } = buildParserFile(source, {\n              })\n              return {\n                contents: parser,\n                loader: 'js'\n              }\n            })\n          }\n        }],\n      minify: !options.debug\n    })\n\n    bundle.warnings?.forEach(console.warn)    \n\n    if (bundle.outputFiles) {\n      script = bundle.outputFiles[0].text.replaceAll(\"</script>\",\"<\\\\/script>\")\n      style = bundle.outputFiles[1].text\n    } else {\n      return\n    }\n\n    /*meta['$css'] = meta['$css'].map((x: string) => {\n      let alt = x.replace('./src/runtime','./dist')      \n      if (fs.existsSync(options.dataDir + '/' + alt)) x = alt      \n      if (options.standalone) {\n        const p = options.dataDir + '/' + x\n        let css = fs.readFileSync(p).toString('utf-8')\n        css = css.replaceAll(/url\\(['\"]?([a-zA-Z\\.\\/0-9_@-]+)['\"]?\\)/g,(x,y) => {\n          const data = fs.readFileSync(path.parse(p).dir + '/' + y).toString('base64')\n          let mime\n          switch (path.parse(y).ext) {\n            case ('.woff'): mime = 'font/woff'; break;\n            case ('.png'): mime = 'image/png'; break;\n            case ('.jpg'): mime = 'image/jpg'; break;\n            case ('.svg'): mime = 'image/svg+xml'; break;\n            default: mime = 'text/plain'; break;\n          }\n          return `url(data:${mime};base64,${data})`\n        })\n        return `<style>\\n${css}\\n</style>`\n      } else return `<link rel=\"stylesheet\" href=\"${x}\"/>`\n    })*/\n\n    meta['$dir'] = \"dist\";\n\n    //const footerTemplateSrc = fs.readFileSync(options.dataDir + \"/templates/submit.html\").toString('utf-8')\n    //const footerTemplate = handlebars.compile(footerTemplateSrc)\n    \n    //if (!options.submission) meta['$footer'] = footerTemplate(meta)\n\n\n    //const templateSrc = fs.readFileSync(options.dataDir + '/templates/ublatt.html').toString('utf-8');\n    //const template = handlebars.compile(templateSrc)\n\n    const footer: string = render(\u00B5 => \u00B5.when(!options.submission, () => Submit({ buttons: 'submit-buttons' })(\u00B5)))\n\n    meta.authors = meta.authors || meta.author.map((x: string) => ({name: x}))\n\n    const output = render(Main({\n      lang: meta.lang,\n      authors: meta.authors || [],\n      pagetitle, \n      header: render(Header(meta)),\n      body,\n      script,\n      style,\n      footer\n    }))\n\n    if (options.out == 'stdout') {\n        process.stdout.write(output)\n    } else {        \n        fs.writeFileSync(options.out, output)\n    }\n}", "import yaml from 'yaml';\nimport { readFile } from 'fs/promises';\nimport { Author } from '../shared/Types';\n\nexport type Metadata = {\n  sheet?: string;\n  title?: string;\n  lang?: string;\n  author?: Author[];\n  [id: string]: any;\n}\n\nexport function loadMetadata(path: string | string[]): Promise<Metadata> {\n  if (typeof path == \"string\") {\n    return readFile(path).then(x => x.toString('utf-8')).then(yaml.parseDocument)\n  } else {\n    return path.map(loadMetadata).reduce(async (a,b) => {\n      const a_ = await a\n      const b_ = await b\n      return mergeMetadata(a_,b_)\n    })\n  }\n}\n\nexport function parseMetadata(input: string): Metadata {\n  return yaml.parse(input)\n}\n\n/** merges all properties set in `from` to `to` */\nexport function mergeMetadata(from: Metadata, to: Metadata): Metadata {\n  Object.keys(from).forEach(key => {\n    to[key] = from[key]\n  })\n  return to\n}\n\n/** extracts metadata blocks from input */\nexport function extractMetadata(input: string, meta: Metadata): string {  \n  const lines = input.split('\\n')\n  var start = null\n  var blank = true\n  var i = 0\n  var buf = \"\"\n  while (i < lines.length) {    \n    if (typeof start == \"number\") {\n      if (lines[i].match(/^(---|...)\\s*$/)) {\n        try {\n          const x = parseMetadata(buf)\n          Object.keys(x).forEach(key => {\n            meta[key] = x[key]\n          })\n          lines.splice(start, i - start + 1)\n        } catch (e) {\n          console.warn(e)\n          i = i - (i - start + 1)\n        }\n        start = null\n        blank = false\n        buf = \"\"\n      } else {\n        buf += lines[i] + \"\\n\"\n      }\n    } else {\n      if (blank && lines[i].match(/^---\\s*$/)) {\n        start = i\n      } else if (lines[i].match(/^\\s*$/)) {\n        blank = true\n      } else {\n        blank = false\n      }\n    }\n    i += 1;\n  }\n  return lines.join('\\n');\n}\n", "import { existsSync, lstatSync, readdirSync, PathLike }  from 'fs';\nimport { parse } from 'path';\n\nexport type Modules = Map<string,Modules>\n\nexport default function extractModules(base: PathLike): Modules {    \n    let result = new Map()  \n    if (existsSync(base) && lstatSync(base).isDirectory) {\n        readdirSync(base).forEach((file) => {\n            const p = parse(file)\n            if (p.ext == '.ts' || p.ext == '.tsx') {\n                let submodules = extractModules(`${base}/${p.name}`)\n                result.set(p.name,submodules)                    \n            }\n        })\n    }\n    return result\n}", "import markdownit from 'markdown-it';\nimport container from 'markdown-it-container';\nimport texmath from 'markdown-it-texmath';\nimport katex from 'katex';\nimport bspans from 'markdown-it-bracketed-spans';\nimport attrs from 'markdown-it-attrs';\nimport secs from 'markdown-it-header-sections';\nimport Token from 'markdown-it/lib/token';\nimport MarkdownIt from 'markdown-it';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport highlightStyle from '../shared/codemirror/highlight';\nimport { highlightTree, styleTags } from '@codemirror/highlight';\nimport { Language } from '@codemirror/language';\nimport languages from '../shared/codemirror/languages';\n\ninterface MarkdownOptions {    \n    dir: string,\n    processClasses?: (classes: string[]) => void,\n    standalone?: boolean\n}\n\nexport default class Markdown {    \n    readonly md: MarkdownIt\n\n    constructor(options: MarkdownOptions) {\n        this.md = markdownit().use(container, 'classes', {\n            validate(params: string) {\n                return params.trim().match(/^(\\w+\\s+)*\\w+$/)\n            },\n            render(tokens: Token[], idx: number) {\n                const classes = tokens[idx].info.trim().split(/\\s+/)\n                options.processClasses?.(classes)\n                if (tokens[idx].nesting === 1) {\n                    // opening tag\n                    return `<div class=\"${classes.join(' ')}\">\\n`;\n                } else {\n                    // closing tag\n                    return '</div>\\n';\n                }\n            }\n        })\n            .use(texmath, { engine: katex, delimiters: 'dollars' })\n            .use(bspans)\n            .use(attrs)\n            .use(secs)\n\n        if (options.processClasses) {\n            const processClasses = options.processClasses\n            const renderAttrs = this.md.renderer.renderAttrs            \n            this.md.renderer.renderAttrs = function (tkn) {\n                if (tkn.attrs) {\n                    const c = tkn.attrs.find(x => x && x[0] == \"class\")\n                    if (c) {\n                        const classes = c[1].split(/\\s+/);\n                        processClasses(classes);\n                    }\n                }\n                return renderAttrs(tkn)\n            }\n        } \n\n        this.md.renderer.rules.image = function (tokens, idx, opts, env, slf) {\n            const token = tokens[idx];            \n            let src = token.attrGet('src')\n            if (src && fs.existsSync(options.dir + '/' + src)) {\n                const mime = 'image/' + path.parse(src).ext.slice(1)\n                const uri = `data:${mime};base64,${fs.readFileSync(options.dir + '/' + src).toString('base64')}`\n                token.attrSet('src', uri)                \n            } else {\n                console.warn(src + \" does not exist\")\n            }\n            return `<figure>${slf.renderToken(tokens,idx,opts)}<figcaption>${slf.renderInline(token?.children || [],opts,env)}</figcaption></figure>`\n        }\n\n        this.md.renderer.rules.fence = function (tokens, idx, options, env: { highlighters: { [key: string]: Language } }, slf) {\n            const token = tokens[idx];\n            let str = token.content\n            if (str.slice(-1) == '\\n') str = str.slice(0,-1)\n            const m = token.info.match(/\\S+/)\n            token.attrJoin('class',token.info)\n            let res = '<div class=\"line\">'                \n            const newline = \"</div><div class='line'>\"                \n            if (m && m[0] && env.highlighters[m[0]]) {\n                const lang = env.highlighters[m[0]]\n                let i = 0                \n                highlightTree(lang.parseString(str),highlightStyle.match,\n                    (from,to,classes) => {\n                        if (i < from)\n                            res += str.slice(i,from).replaceAll('\\n',newline)\n                        res += `<span class=\"${classes}\">`\n                        res += str.slice(from,to).replaceAll('\\n',`</span>${newline}<span class=${classes}>`)\n                        res += '</span>'\n                        i = to\n                    }\n                )\n                res += str.slice(i).replaceAll('\\n',newline)                \n            } else {\n                res += str.replaceAll('\\n',newline)\n            }   \n            \n            res += '</div>'            \n        \n            return '<pre' + slf.renderAttrs(token) + '>'\n                + '<code>' + res + '</code>'\n                + '</pre>';\n        }\n    }\n\n    public async render(input: string): Promise<string> {\n        const env: { highlighters: { [key: string]: Language } } = {\n            highlighters: {}\n        }\n        const parse = this.md.parse(input,env)        \n        const extractLanguages = async (tkn: Token) => {\n            if (tkn.type == 'fence') {\n                const m = tkn.info.match(/\\S+/)\n                if (m && m[0]) {\n                    if (languages[m[0]])\n                      env.highlighters[m[0]] = await languages[m[0]]()\n                }\n                return\n            } else {             \n                if (tkn.children) {\n                    await Promise.all(tkn.children.map(extractLanguages))\n                }                \n                return\n            }\n        }        \n        await Promise.all(parse.map(extractLanguages))\n        const res = this.md.renderer.render(parse,this.md.options,env)\n        return res\n    }\n}", "import { HighlightStyle, tags } from '@codemirror/highlight'\n\nexport default HighlightStyle.define(\n  {\n    tag: tags.link,\n    textDecoration: \"underline\"\n  },\n  {\n    tag: tags.heading,\n    textDecoration: \"underline\",\n    fontWeight: \"bold\"\n  },\n  {\n    tag: tags.function(tags.variableName),\n    color: \"#795e26\"\n  },\n  {\n    tag: tags.emphasis,\n    fontStyle: \"italic\"\n  },\n  {\n    tag: tags.strong,\n    fontWeight: \"bold\"\n  },\n  {\n    tag: tags.keyword,\n    color: \"#00f\"\n  },\n  {\n    tag: tags.controlKeyword,\n    color: \"#af00db\"\n  },\n  {\n    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n    color: \"#219\"\n  },\n  {\n    tag: [tags.literal, tags.inserted],\n    color: \"#098658\"    \n  },\n  {\n    tag: [tags.string, tags.deleted],\n    color: \"#a31515\"\n  },\n  {\n    tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n    color: \"#e40\"\n  },\n  {\n    tag: tags.definition(tags.variableName),\n    color: \"#0070c1\"\n  },\n  {\n    tag: tags.local(tags.variableName),\n    color: \"#30a\"\n  },\n  {\n    tag: [tags.typeName, tags.namespace],\n    color: \"#267f99\"\n  },\n  {\n    tag: tags.className,\n    color: \"#267f99\"\n  },\n  {\n    tag: [tags.special(tags.variableName), tags.macroName, tags.local(tags.variableName)],\n    color: \"#256\"\n  },\n  {\n    tag: tags.propertyName,\n    color: \"#001080\"\n  },  \n  { \n    tag: tags.definition(tags.propertyName),\n    color: \"#001080\"\n  },\n  {\n    tag: tags.comment,\n    color: \"#008000\"\n  },\n  {\n    tag: tags.meta,\n    color: \"#7a757a\"\n  },\n  {\n    tag: tags.invalid,\n    color: \"#f00\"\n  }\n)", "// This file was generated by lezer-generator. You probably shouldn't edit it.\nimport {Parser} from \"lezer\"\nconst spec_simpleName = {__proto__:null,package:8, context:14, Set:23, Bag:25, Sequence:27, Collection:29, OrderedSet:31, Tuple:33, pre:48, and:56, or:58, xor:60, implies:62, self:66, true:92, false:94, null:98, invalid:102, let:106, in:108, if:118, then:120, else:122, endif:124, OclAny:127, OclInvalid:129, OclMessage:131, OclVoid:133, init:134, derive:136, inv:138, static:140, def:142, post:146, body:148, endpackage:150}\nexport const parser = Parser.deserialize({\n  version: 13,\n  states: \":jQ]QPOOOOQO'#ES'#ESOOQO'#Dz'#DzQ`QPOOQOQPOOOeQPO'#ExOjQPO'#EOOOQO-E7x-E7xOoQPO,5;dOOQO'#EQ'#EQO!QQPO,5;dO!`QPO,5;hOOQO'#Ca'#CaO!kQPO,5:jOjQPO1G1OO!vQPO1G0ZO!{QPO'#EyO#TQPO'#EyO#]QPO'#EyOOQO1G1O1G1OO#bQPO'#E}OOQO1G1S1G1SO#gQPO,5:lO#lQPO1G0UOOQO1G0U1G0UO#tQPO7+&jO$SQPO'#CbOOQO1G0W1G0WO$hQPO1G1RO$mQPO7+%uO$rQPO,5;eO%|QPO,5;eO&RQPO,5;eO&WQPO,5;eO&]QPO,5;eO&eQPO,5;iOOQO'#Cb'#CbOOQO7+%p7+%pOOQO<<JU<<JUO&jQPO7+&mO'gQPO<<IaO)UQPO'#CaO*bQPO'#DPO+zQPO1G1POOQO'#Cq'#CqOOQO'#Cp'#CpO,XQPO'#DROOQO'#DX'#DXOOQO'#DW'#DWOOQO'#DO'#DOOOQO'#Co'#CoOOQO'#EX'#EXOOQO'#C|'#C|O,^QPO'#DVOOQO'#DZ'#DZOOQO'#D^'#D^OOQO'#D`'#D`O,cQPO'#DbO$rQPO'#DhO$rQPO1G1PO,hQPO'#CaO-VQPO'#E{O-[QPO'#CmOOQO'#Ez'#EzO.VQPO'#EzO.[QPO1G1PO&RQPO1G1PO.pQPO1G1PO$rQPO1G1TOOQO'#Cn'#CnO.uQPO'#E]O/TQPO<<JXO/YQPO<<JXO/_QPO'#CaO0iQPO'#EVO0nQPO'#EWOOQO'#EV'#EVO0sQPO'#E[OOQO'#Ev'#EvO0xQPOAN>{O1QQPO,5:lO1VQPO,59aO$rQPO,59cO$rQPO,59cO$rQPO,59cO$rQPO,59cO1[QPO,5:PO$rQPO,59cO$rQPO,59cO$rQPO,59cOOQO7+&k7+&kO$rQPO,59mO,cQPO,59qO1aQPO,59|O2pQPO,5:SO2wQPO7+&kO3UQPO,5:lO$rQPO,59XO3ZQPO,59XO$rQPO,5;fO4TQPO7+&kO&RQPO7+&kO4iQPO7+&oO,cQPO,5:wO5PQPOAN?sO5mQPOAN?sO5rQPO,5:lO5wQPO,5:rO,cQPO,5:vO6OQPO'#EwOOQOG24gG24gO6TQPO'#CbOOQO1G/V1G/VO8pQPO'#CsO;`QPO1G.xOOQO1G.{1G.{O=wQPO1G.}O>RQPO1G.}O@iQPO1G.}O@yQPO1G.}OAZQPO1G/kOCuQPO1G.}OC|QPO1G.}OEXQPO1G.}OFqQPO'#DTOOQO'#DT'#DTOGOQPO'#DSOGWQPO1G/XOG]QPO1G/]O$rQPO1G/hO$rQPO1G/nOOQO<<JV<<JVOGbQPO'#CbOGjQPO1G.sOHaQPO1G.sOIXQPO1G1QOIoQPO<<JVOOQO<<JZ<<JZOOQO1G0c1G0cOOQOG25_G25_OJTQPOG25_OJqQPO'#CbOOQO1G0]1G0]OK{QPO1G0^OLQQPO1G0bO$rQPO,5;cOLVQPO,59_OMcQPO7+$dOMmQPO7+%VO$rQPO,59pO$rQPO,59nOOQO7+$s7+$sOOQO7+$w7+$wOMtQPO7+%SO! ^QPO7+%YO$rQPO7+$_OOQOAN?qAN?qOOQOLD*yLD*yOOQO7+%x7+%xOOQO7+%|7+%|O! eQPO1G0}O! xQPO1G.yO!$eQPO'#CaO!$uQPO'#EdOOQO<<HO<<HOO!%PQPO<<HOO!%UQPO<<HOO!%^QPO'#DgO!%hQPO'#DgO!%sQPO'#DfO!%{QPO<<HqO!&QQPO1G/[OOQO1G/Y1G/YO$rQPO<<HtO!&[QPO<<GyOOQO7+&i7+&iO$rQPO,5;OOOQOAN=jAN=jO!'RQPOAN=jO,cQPOAN=jO!'YQPO,5:ROMmQPO,5:QOOQOAN>]AN>]O!'dQPOAN>`OOQO1G0j1G0jOOQOG23UG23UO!'kQPOG23UO!'pQPOG23UOOQO1G/m1G/mOOQO1G/l1G/lOOQOG23zG23zOOQOLD(pLD(pO!'uQPOLD(pOOQO!$'L[!$'L[O!'|QPO!$'L[OOQO!)9Av!)9Av\",\n  stateData: \"!(R~O!qOSPOSQOS~OSUOVTO~O!sWO~O!s[O~O!x^O!gTX!hTX!iTX!uTX~O!g`O!hbO!iaO!u_O~OhdO!kdO!ldO~OVTO!mhO!ufO~O!sjO~O!soO!xnO~O!sqO!xpO~O!irO~O!ssO~O!stO~OVTO!muO~O!g`O!hbO!iaO!ufO~O!gUX!hUX!iUX!uUX!xWX!|!jX~O!|wO~O!xxO~OZ!TO[!TO]!TO^!TO_!TO`!VOq!UO|!QO!O!WO!P!WO!R!XO!T!YO!V!ZO!]![O!syO#X!PO#e!PO#f!PO~O!x!]O~O!s!^O~O!x!dO~O!s!eO!x!dO~O!x!fO~O!s!gO!}!iO~OZ!TO[!TO]!TO^!TO_!TO`!oO!a!pO!b!pO!c!pO!d!pO!s!kO~O!e!yP!f!yP~P&rOlpXmpXnpXopX!uTX#QpX#RpX#SpX#XpX#YpX#ZpX#[pX#]pX#^pX#_pX#`pX#apX#gpX#hpX#UpX!}pX~OVpX!gpX!hpX!ipX!opX!^pXhpX!kpX!lpX#cpX#dpX!mpX!WpX!_pX!epX!fpX!`pX#VpX~P'qO!u!rO~Ol!yOm!zOn!zOo!{O!g`O!hbO!iaO#Q!wO#R!sO#S!sO#X!tO#Y!tO#Z!uO#[!uO#]!vO#^!vO#_!vO#`!vO#a!wO#g!xO#h!xO~OV#mi!o#mi!m#mi~P*gO#b!}O~O#b#OO~O!s!gO~OVbX!gbX!hbX!ibX!obX!uTX!xbX#QbX!mbX~O!u#SO~O!x#UO#Q#TOVaX!gaX!haX!iaX!oaX!}aX#UaX!WaX#daX!maX#VaX~O#Q#VO~O!g`O!hbO!iaOV#mi!o#mi!m#mi~O!x#XO~O#U#ZO!}#PX!W#PX#d#PX~O!x#[O~O!}#]O~O!eYX!fYX!uTXVYX!gYX!hYX!iYX!oYX#QYX!}YX#UYXhYX!kYX!lYX!WYX#dYX!mYX#VYX~O!u#^O~O!|#_O~O!|#`O~O!e#aO!f#aO~O!s#cO~O!s#eO~O!s#lO~O!W#uO~Ol!yOm!zOn!zOo!{O#Q!wO#R!sO#S!sO#X!tO#Y!tO#Z!uO#[!uO#]!vO#^!vO#_!vO#`!vO#a!wO#g!xO#h!xO~O!^#vO~P1fOV#mq!o#mq!m#mq~P*gO!s#xO~OV!yP!g!yP!h!yP!i!yP!o!yP#Q!yP!}!yP#U!yP!W!yP#d!yP!m!yP#V!yP~P&rO!g`O!hbO!iaOV#mq!o#mq!m#mq~OhdO!kdO!ldOV#qq!o#qq!m#qq~P1fOh!yPh#o!R!k!yP!k#o!R!l!yP!l#o!R#Q!yP#Q#o!R~P&rO!x$QO~O!s$RO~O!}!yP~P&rO!x$VO~OVtXltXmtXntXotX!gtX!htX!itX!otX!uUX#QtX#RtX#StX#XtX#YtX#ZtX#[tX#]tX#^tX#_tX#`tX#atX#gtX#htX!^tXhtX!ktX!ltX#UtX#ctX#dtX!mtX!}tX!WtX!_tX!etX!ftX!`tX#VtX~O#T$WOVjXljXmjXnjXojX!gjX!hjX!ijX!ojX!|gX#QjX#RjX#SjX#XjX#YjX#ZjX#[jX#]jX#^jX#_jX#`jX#ajX#gjX#hjX!^jXhjX!kjX!ljX#UjX#cjX#djX!mjX!}jX!WjX!_jX!ejX!fjX!`jX#VjX~O!|$XO~O#R!sO#S!sOVkilkimkinkioki!gki!hki!iki!oki#Qki#Zki#[ki#]ki#^ki#_ki#`ki#aki#gki#hki!^kihki!kki!lki#Uki#cki#dki!mki!}ki!Wki!_ki!eki!fki!`ki#Vki~O#Xki#Yki~P;eO#X!tO#Y!tO~P;eO#R!sO#S!sO#X!tO#Y!tO#Z!uO#[!uOVkilkimkinkioki!gki!hki!iki!oki#Qki#aki#gki#hki!^kihki!kki!lki#Uki#cki#dki!mki!}ki!Wki!_ki!eki!fki!`ki#Vki~O#]ki#^ki#_ki#`ki~P>]O#]!vO#^!vO#_!vO#`!vO~P>]O!|$YO~O#Q!wO#R!sO#S!sO#X!tO#Y!tO#Z!uO#[!uO#]!vO#^!vO#_!vO#`!vO#a!wOVkimkinkioki!gki!hki!iki!oki#gki#hki!^kihki!kki!lki#Uki#cki#dki!mki!}ki!Wki!_ki!eki!fki!`ki#Vki~Olki~PA`Ol!yO~PA`Ol!yOm!zOn!zOo!{O#Q!wO#R!sO#S!sO#X!tO#Y!tO#Z!uO#[!uO#]!vO#^!vO#_!vO#`!vO#a!wO~OVki!gki!hki!iki!oki#gki#hki!^kihki!kki!lki#Uki#cki#dki!mki!}ki!Wki!_ki!eki!fki!`ki#Vki~PDTO#c$ZO#UwX#dwX~P1fO#U$[O#dvX~O#d$]O~O#d$^O~O!uUX!|!jX~OVai!gai!hai!iai!oai!}ai#Uai!Wai#dai!mai#Vai~P1fO#Q$aOVai!gai!hai!iai!oai!}ai#Uai!Wai#dai!mai#Vai~OV#ni!g#ni!h#ni!i#ni!o#ni!m#ni~P1fO!g`O!hbO!iaOV#my!o#my!m#my~Oh!yPh#o!Z!k!yP!k#o!Z!l!yP!l#o!Z#Q!yP#Q#o!Z~P&rO!eXX!fXX!uUXVXX!gXX!hXX!iXX!oXX#QXX!}XX#UXXhXX!kXX!lXX!WXX#dXX!mXX#VXX~O!}$dO~O!}$eO~Oh$gO~OZ!TO[!TO]!TO^!TO_!TO`!VOq!UO|!QO!O!WO!P!WO!R!XO!T!YO!V!ZO!]![O#X!PO#e!PO#f!PO~O!s$hO!}$jO~PL[O#i$nO~P$rOV!Uq!g!Uq!h!Uq!i!Uq!o!Uq#g!Uq#h!Uq!^!Uqh!Uq!k!Uq!l!Uq#U!Uq#c!Uq#d!Uq!m!Uq!}!Uq!W!Uq!_!Uq!e!Uq!f!Uq!`!Uq#V!Uq~PDTO!_$sO~P1fO!e#aO!f#aOV#ki!o#ki!m#ki~P1fOVjiljimjinjioji!gji!hji!iji!oji!|gi#Qji#Rji#Sji#Xji#Yji#Zji#[ji#]ji#^ji#_ji#`ji#aji#gji#hji!^jihji!kji!lji#Uji#cji#dji!mji!}ji!Wji!_ji!eji!fji!`ji#Vji~O!xbX#QbX#UbX#VbX~P'qO#U$vO!}#WX~P1fO!}$wO~O#U$yO#V$xO~O!}!ZX#U!ZX~P1fO!x$zO!}!ZX#U!ZX~O#U${O!}!YX~O!}$|O~O#Uxi#dxi~P1fOVay!gay!hay!iay!oay!}ay#Uay!Way#day!may#Vay~P1fO!}%PO~P$rO!}!yP#U!yP~P&rO!`%UO~P1fO!}%VO~O#V%WO~O!}%XO~P$rO!}%ZO~O\",\n  goto: \"/p#rPPPPP#s$nP$u$x${PPPPPP%T%g%s'^'{(j)XP(j)['^PPPP'^P'^)_)|)_*P*V*Z)_)_*_P*_PP*_P*_P'^PP'^*|+S'^PPPPPPPPPPPPP+WPPP+[PPP+fP+iP,n,tP,z${-^PP${.TPPPPPP.dPPPPPPPPPPPPPPPPP${.p,t.v/X/b,t/j!qXTU^npx![!]!d!f!t!u!v!w!y!z!{!}#T#U#V#X#[#_#u#v$Q$V$X$Y$Z$[$a$s$v$x$z${%WZk_f!r#S#^Rm_R$S#^]!nx#U#[#_$Q$zU!ap!d#XY!hw!Z#O#Z#`Q$l$XR%R$ye!`pw!Z!d#O#X#Z#`$X$yQ{nQ#Q![Q#R!]Q#Y!fQ#h!tQ#i!uQ#j!vQ#k!wQ#m!yQ#n!zQ#o!{S#p!}$[Q#y#TQ#{#VQ$_#uQ$`#vQ$f$VW$i$X$v$x%WS$m$Y${Q$q$ZQ$t$aR$}$s!X!Sn![!]!f!t!u!v!w!y!z!{!}#T#V#u#v$V$X$Y$Z$[$a$s$v$x${%W!X}n![!]!f!t!u!v!w!y!z!{!}#T#V#u#v$V$X$Y$Z$[$a$s$v$x${%W!X|n![!]!f!t!u!v!w!y!z!{!}#T#V#u#v$V$X$Y$Z$[$a$s$v$x${%WR#f!sR#g!s!X!Rn![!]!f!t!u!v!w!y!z!{!}#T#V#u#v$V$X$Y$Z$[$a$s$v$x${%WR#d!rQ#s!}R$r$[T#r!}$[T#q!}$[!X!Qn![!]!f!t!u!v!w!y!z!{!}#T#V#u#v$V$X$Y$Z$[$a$s$v$x${%WQ$p$YR%T${T$o$Y${Tl_#SQROSVRgRg]RSOQYTQ]UQi^!Wzn![!]!f!t!u!v!w!y!z!{!}#T#V#u#v$V$X$Y$Z$[$a$s$v$x${%WU!_p!d#X]!lx#U#[#_$Q$zXQOR]gXPOR]gQ!qxQ#z#UQ$P#[Q$T#_Q$c$QR%S$z!W!On![!]!f!t!u!v!w!y!z!{!}#T#V#u#v$V$X$Y$Z$[$a$s$v$x${%W]!mx#U#[#_$Q$zQ!jwQ#P!ZQ#t#OQ$O#ZR$U#`Q$k$XQ%O$vQ%Q$xR%Y%WQ#b!qR$u$fQcYQviS!|{!cS#w#R#WR$b#|Q!cpQ#W!dR#|#XQZTV!bp!d#XQeZR#}#Y\",\n  nodeNames: \"\u26A0 LineComment BlockComment ExpressionInOcl package Namespace Namespace context PropertyName Type Type Set Bag Sequence Collection OrderedSet Tuple VariableDeclaration VariableName OclExpression CallExp FeatureCallExp OperationCallExp MethodName pre PropertyCallExp PropertyName BinaryExp and or xor implies VariableExp self LiteralExp EnumLiteralExp EnumLiteral CollectionLiteralExp CollectionLiteralParts CollectionLiteralPart CollectionRange TupleLiteralExp PrimitiveLiteralExp NumericLiteral StringLiteral BooleanLiteralExp true false NullLiteralExp null InvalidLiteralExp invalid LetExp let in OclMessageExp OclMessageArguments OclMessageArg IfExp if then else endif OclAny OclInvalid OclMessage OclVoid init derive inv static def MethodName post body endpackage\",\n  maxTerm: 125,\n  skippedNodes: [0,1,2],\n  repeatNodeCount: 1,\n  tokenData: \"-R~RsX^#`pq#`tu$Twx$ixy%ayz%fz{%k{|%p|}%u}!O%z!O!P&g!P!Q&t!Q!R't!R![*a![!]+T!^!_+b!_!`+w!`!a+|!a!b,Z!b!c,`!c!}$T#Q#R,e#R#S$T#T#o$T#o#p,r#p#q,w#q#r,|#y#z#`$f$g#`#BY#BZ#`$IS$I_#`$I|$JO#`$JT$JU#`$KV$KW#`&FU&FV#`~#eY!q~X^#`pq#`#y#z#`$f$g#`#BY#BZ#`$IS$I_#`$I|$JO#`$JT$JU#`$KV$KW#`&FU&FV#`~$YT!s~tu$T!Q![$T!c!}$T#R#S$T#T#o$T~$lUOY$iZw$iwx%Ox#O$i#O#P%T#P~$i~%TO|~~%WROY$iYZ$iZ~$i~%fO!|~~%kO!}~~%pO#X~~%uO#Z~~%zO#U~~&PQ#[~}!O&V!`!a&b~&[QP~OY&VZ~&V~&gO#R~~&lP#S~!O!P&o~&tO#c~~&yP#Y~z{&|~'PSOz&|z{']{!P&|!Q~&|~'`TOz&|z{']{!P&|!P!Q'o!Q~&|~'tOQ~~'yR#e~!O!P(S!g!h)g#X#Y)g~(VP!Q![(Y~(_R#f~!Q![(Y!g!h(h#X#Y(h~(kS{|(w}!O(w!Q!R)Q!R![)V~(zQ!Q!R)Q!R![)V~)VO#f~~)[P#f~!Q![)_~)dP#f~!Q![)_~)jS{|)v}!O)v!Q!R)Q!R![*P~)yQ!Q!R)Q!R![*P~*UP#f~!Q![*X~*^P#f~!Q![*X~*fS#e~!O!P(S!Q![*r!g!h)g#X#Y)g~*wS#e~!O!P(S!Q![*r!g!h)g#X#Y)g~+YP!x~![!]+]~+bO!u~~+gQ#]~!_!`+m!`!a+r~+rO#_~~+wO#a~~+|O#Q~~,RP#^~!_!`,U~,ZO#`~~,`O#i~~,eO#T~~,jP#g~#Q#R,m~,rO#h~~,wO#b~~,|O#V~~-RO#d~\",\n  tokenizers: [0],\n  topRules: {\"ExpressionInOcl\":[0,3]},\n  specialized: [{term: 81, get: value => spec_simpleName[value] || -1}],\n  tokenPrec: 0\n})\n", "import { Language } from \"@codemirror/language\"\n\nconst languages: { [lang: string]: () => Promise<Language> } = {\n  javascript: () => import(\"@codemirror/lang-javascript\").then(x => x.javascriptLanguage),\n  typescript: () => import(\"@codemirror/lang-javascript\").then(x => x.typescriptLanguage),\n  jsx: () => import(\"@codemirror/lang-javascript\").then(x => x.jsxLanguage),\n  tsx: () => import(\"@codemirror/lang-javascript\").then(x => x.tsxLanguage),\n  python: () => import(\"@codemirror/lang-python\").then(x => x.pythonLanguage),\n  cpp: () => import(\"@codemirror/lang-cpp\").then(x => x.cppLanguage),\n  css: () => import(\"@codemirror/lang-css\").then(x => x.cssLanguage),\n  markdown: () => import('@codemirror/lang-markdown').then(x => x.markdownLanguage),\n  ocl: () => import('../languages/ocl').then(x => x.default)\n}\n\nlanguages.py = languages.python\nlanguages.ts = languages.typescript\nlanguages.js = languages.javascript\n\nexport default languages", "// @ts-ignore\nimport externals from '../../externals.json';\n// @ts-ignore\nimport pack from '../../package.json';\n\ntype Dict = { [key: string]: string }\n\nexport default {\n    filter: RegExp(`^(${Object.keys(externals).join('|')})$`),\n    path(key: string): string | undefined {        \n        return (externals as Dict)[key].replace(/\\$\\{\\s*version\\s*\\}/,(pack.dependencies as Dict)[key])\n    } \n}", "import type { Author } from '../Types'\nimport type { Renderer, Fragment } from './template'\n\nexport default function <T extends Renderer> (props: {\n  lang: string\n  authors: Author[]\n  pagetitle: string\n  script: string\n  style: string\n  header?: Fragment<T>\n  body: Fragment<T>\n  footer?: Fragment<T>\n}) {\n  return (h: T) =>\n    h.fragment(\n      h.fromString('<!DOCTYPE html>'),\n      h('html',{ lang: props.lang },  \n        h('head',{},\n          h('meta',\u00A0{ name: 'generator', content: 'ublatt' }),          \n          h('meta', { attributes: { charset: 'utf-8' }}),\n          h.fragment(...props.authors.map(a => h('meta',{ name: 'author', content: a.name }))),\n          h('title',{},props.pagetitle),\n          h('script',{ type: 'module' },props.script),\n          h('style',{},props.style)\n        ),\n        h('body',{},\n          h('form',{ class: 'ublatt' },\n            props.header,\n            h('div',{ class: 'main' }, props.body),\n            props.footer\n          )\n        )\n      )  \n    )\n}", "import { Author } from '../Types'\nimport type { Renderer, HTML } from './template'\n\nexport default function<T extends Renderer>(props: {\n  title?: string  \n  subtitle?: string\n  authors?: Author[]\n  sheet?: string\n  date?: string\n  due?: string\n}) {\n  return (h: T) => \n    h('div',{ class: 'head' },\n      h.when(props.title, () => h('span',{ class: 'title' },props.title)),\n      h.when(props.subtitle, () => h('span',{ class: 'term' },props.subtitle)),\n      h('ul',{ class: 'lecturers' },\n        ...(props.authors || []).map(a => h('li',{},a.name))\n      ),\n      h.when(props.sheet, () => h('span',{ class: 'sheetnum' },`${props.sheet}. \u00DCbungsblatt`)),    \n      h.when(props.date, () => h.fragment(\n        h('span',{ class: 'issued-title' }, 'Ausgabe: '),\n        h('span',{ class: 'issued' }, props.date)\n      )),\n      h.when(props.due, () => h.fragment(\n        h('span',{ class: 'due-title' }, 'Abgabe: '),\n        h('span',{ class: 'due' }, props.due)\n      ))  \n    )\n}", "import { Renderer } from \"./template\";\n\nexport default function <T extends Renderer> (props: {\n  buttons: string\n}) {\n  return (\u00B5: T) => (\n    \u00B5('div', { class: 'submit' },      \n      \u00B5('h1', {}, 'Abgabe'),\n      \u00B5('div', { class: 'row' },\n        \u00B5('div', {},          \n          \u00B5('p',{},'Bitte gebt alle Autoren mit Matrikelnummer und Emailaddresse ' +\n            'an und speichert dann eure L\u00F6sung. Die gespeicherte JSON Datei sendet ' +\n            'ihr dann an beide Tutoren per E-Mail.')          \n        ),\n        \u00B5('div', {},          \n          \u00B5('div', { class: 'authors' })\n        )\n      ),\n      \u00B5('div',{ class: 'buttons', id: props.buttons }\n    )\n  ))  \n}", "\nimport { StaticRenderer, HTML, Props } from \"../shared/templates/template\";\n\nconst voidTags = new Set<HTML>([\n  'area','base','br','col','embed','hr','img','input',\n  'link','meta','param','source','track','wbr'])\n\nexport const renderer: StaticRenderer = Object.assign(\n  function <K extends HTML>(k: K, props: Props<K>, ...children: string[]): string {\n    const attrs = Object.entries(props).map(([k,v]) => {\n      switch (k) {\n        case 'attributes':\n          return Object.entries(v).map(([k,v]) => `${k}=\"${v}\"`).join(' ')\n        case 'data':\n          return Object.entries(v).map(([k,v]) => `data-${k}=\"${v}\"`).join(' ')\n        case 'class':\n          return `class=\"${Array.isArray(v) ? v.join(' ') : v}\"`\n        default:\n          return `${k.toLowerCase()}=\"${v}\"`        \n      }\n    }).join(' ')\n    if (children.length == 0 && voidTags.has(k)) {    \n      return `<${k} ${attrs}/>`\n    } else {\n      return `<${k} ${attrs}>\\n${children.join('')}\\n</${k}>`\n    }\n  },\n  {\n    fragment(...items: string[]) {\n      return items.join('')\n    },    \n    fromString(v: string) {\n      return v\n    },\n    empty() { return '' },\n    when(p: any, t: () => string) {\n      return p ? t() : ''\n    } \n  }\n)\n\nexport default function render(template: (r: StaticRenderer) => string) {\n  return template(renderer)\n}", "import { Solution, Student } from '../shared/Types'\nimport * as fs from 'fs';\nimport * as path from 'path'\n\ntype SummaryOptions = {\n  dir: string\n}\n\nexport default function summary(options: SummaryOptions) {\n    let course: string | null = null\n    const sheets: { [id: string]: Solution[] } = {}\n    const students: { [id: string]: Student } = {}\n    const handins: { [id: string]: { [id: string]: Solution }} = {}\n    fs.readdirSync(options.dir).filter(x => path.parse(x).ext == '.json').map(x => {        \n      const src = fs.readFileSync(options.dir + x).toString('utf-8')\n      const obj = JSON.parse(src) as Solution\n      if (course == null) {\n        course = obj.course\n      } else if (course != obj.course) {\n        console.error(`- found submissions to multiple courses (${course} and ${obj.course})`)\n      }\n      obj.authors.forEach(a => {        \n        students[a.matriculation_number] = students[a.matriculation_number] || a\n        if (!handins[a.matriculation_number]) handins[a.matriculation_number] = {}\n        if (handins[a.matriculation_number][obj.sheet])\n          console.warn(`- multiple submissions for sheet ${obj.sheet} from ${a.name} (${a.matriculation_number})`)\n        else\n          handins[a.matriculation_number][obj.sheet] = obj\n      })\n      if (!sheets[obj.sheet]) sheets[obj.sheet] = []\n      sheets[obj.sheet].push(obj)\n    })\n    console.log(\"## Sheets\\n\")\n    Object.entries(sheets).forEach(([x,y]) => {\n      console.log(`- sheet ${x}: ${y.length} handins from ${y.map(x => x.authors.length).reduce((x,y) => x + y)} students`)\n    })    \n    console.log(\"\\n## Missing handins\\n\")\n    Object.entries(students).forEach(([x,y]) => {\n      const e = handins[y.matriculation_number]\n      const missing = Object.keys(sheets).filter(x => e[x] === undefined)    \n      if (missing.length > 0) \n        console.log(`- ${y.name} (${x}): ${missing.join(\", \")}`)\n    })\n    console.log(\"\\n\")\n    \n}", "import { Solution, Student } from '../shared/Types'\nimport * as fs from 'fs';\nimport build, { BuildOptions }  from './build';\nimport { extractMetadata, Metadata, parseMetadata } from './metadata';\n\ntype EvaluateOptions = BuildOptions & {  \n  file: fs.PathLike\n}\n\nexport default function evaluate(options: EvaluateOptions) {  \n  function makeBuildOptions(s: Solution): BuildOptions {\n    const opts = Object.assign({},options)\n    const y = fs.readdirSync('./solutions') // TODO: make search path configurable\n      .filter(x => x.endsWith('.json'))\n      .map(x => JSON.parse(fs.readFileSync('./solutions/' + x).toString('utf-8')) as Solution)\n      .find(x => x.sheet == s.sheet)\n    const z = fs.readdirSync('./sheets') // TODO: make search path configurable\n      .filter(x => x.endsWith('.md'))\n      .map(x => './sheets/' + x).find(x => {\n        const meta: Metadata = {}\n        extractMetadata(fs.readFileSync(x).toString('utf-8'), meta)\n        return meta.sheet == s.sheet\n      })\n    opts.submission = s\n    opts.solution = y\n    if (!z) throw new Error(\"could not find sheet\")\n    opts.source = z\n    return opts\n  }\n  if (fs.statSync(options.file).isDirectory()) {\n    const counters: { [i: string]: number } = { }\n    const xs = fs.readdirSync(options.file).filter(x => x.endsWith('.json')).forEach(x => {          \n      const c = fs.readFileSync(options.file + '/' + x).toString('utf-8')\n      const s = JSON.parse(c) as Solution\n      const opts = makeBuildOptions(s)\n      const n = counters[s.sheet] = counters[s.sheet] + 1 || 1      \n      opts.out = `${options.file}/sheet${s.sheet}-${n}.html`\n      build(opts)\n    })\n  } else {\n    const x = fs.readFileSync(options.file).toString('utf-8')\n    const s = JSON.parse(x) as Solution\n    build(makeBuildOptions(s))\n  }\n}"],
  "mappings": "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",
  "names": []
}
